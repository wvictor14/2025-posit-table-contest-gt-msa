---
title: "Visualizing Multiple Sequence Aligments with r-gt!"
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
    code-tools: true
    anchor-sections: true
    html-table-processing: none
editor: 
  render-on-save: true
editor_options: 
  chunk_output_type: console
---

Multiple sequence alignment (MSA) is a technique to understand the similarity and differences between biological sequences. This technique is useful for identifying conserved functional regions, and understanding evolutionary relationships.

For the 2025 Posit Table contest I wanted to explore how MSAs can be visualized using the r package [gt](https://gt.rstudio.com/). This has been something I have wanted to do for a long time. So I'm excited for this opportunity.

The data we are working with is an msa from [@Wang2021], where they identified a potential universally conserved "weak spot" in Coronavirus spike proteins using cross-reactive monoclonal antibodies. Finding antibodies specific to the spike protein were essential steps to developing the COVID-19 vaccines that saved millions of lives in the pandemic.

[Figure 5](https://www.nature.com/articles/s41467-021-21968-w/figures/5), shows an MSA of COVID spike proteins from several coronavirus species: SARS-CoV, SARS-CoV-2, MERS-COV, and HCoV-OC43 (the common cold). The visualization left an impression on me. Clearly there is large divergence between these protein sequences, yet they share a region with enough similarity that these authors were able to identify binders reactive to all species!

# Setup {.hidden}

Libraries

```{r}
#| message: false
library(dplyr)
library(here)
library(tidyr)
library(gt)
library(stringr)
library(readr)
library(htmltools)
library(glue)
```

Data

```{r}
# palette
palette_aa <- readr::read_csv('palette_amino_acids.csv')

# msa data
FILE_MSA <- 'msa.csv'
msa <- readr::read_csv(FILE_MSA)

# long format
msa_long <- msa |>  
  mutate(seq = as.character(seq) |> str_split('')) |> 
  tidyr::unnest(seq) |> 
  mutate(position = row_number(), .by = name) 

# table data
tbl_data <- msa_long |> 
  pivot_wider(
    id_cols = c(group, name, start),
    names_from = 'position',
    values_from = 'seq',
    names_prefix = 'pos_'
  )
```

Custom functions

## Palette

```{r}
#' returns a coloring function based on chosen palette
apply_color_to_aa <- function(
    letter, 
    palette = c(
      'Chemistry_AA', 
      'Shapely_AA', 
      'Zappo_AA', 
      'Taylor_AA', 
      'LETTER',  
      'Hydrophobicity'
    )
) {
  target_palette <- palette_aa[,c('symbol', palette[1])] |> tibble::deframe()
  
  color_fn <- function(letter) {
    color <- target_palette[letter]
    color[is.na(color)] <- 'grey'
    return(color)
  }
}
```

## Consensus

```{r}
#' This version sets the parent div to be 100% width and height
#' @param bar_height a number between 0 and 1 that sets the height of the bar as a percentage of the total height of the container (the parent) div
#' @param parent_div_height valid css unit for height of the parent div
#' @param parent_div_width valid css unit for width of the parent div
create_html_vertical_bar <- function(
    bar_height = .5,
    bar_color = '#4a6fa5',
    parent_div_height = '50px', 
    parent_div_width = '100%'
) {
  .bar_height <- bar_height*100
  div(
    style=glue("width:{parent_div_width};height:{parent_div_height};margin:0;padding:0;"),
    div(style=glue("height:{100-.bar_height}%;background:transparent;margin:0;padding:0;")),
    div(style=glue("height:{.bar_height}%;background:{bar_color};margin:0;padding:0;"))
  )
}

#' Get conensus frequency
#' 
#' returns a 1-length named character vector of the most frequent amino acid, where:
#'  - the value is the frequency
#'  - the name is amino acid
#'  
#' Does not handle ties (one of the ties will be returned)
#' @param x a vector, ideally of interesting biological sequences
get_consensus <- function(x) {
  
  # drop gaps
  frequency_tbl <- x |> table() |>  sort(decreasing = TRUE)
  consensus_freq <- (frequency_tbl/sum(frequency_tbl))[1]
  
  return(consensus_freq)
}

#' gets the consensus of the vector x, and returns an html bar
get_consensus_return_bar <- function(x) {
  consensus_freq <- get_consensus(x)
  create_html_vertical_bar(consensus_freq) 
}

# usage:
c('X', 'X', 'O')|>  get_consensus_return_bar()  |> browsable()
c('X', 'O')|>  get_consensus_return_bar()  |> browsable()
```

breaks

```{r}
#' Treats the column names as an axis, and generates breaks using `scales::breaks_width`
#' 
#' @return a vector of column names at every `width` position 
generate_breaks <- function(tbl, width = 5) {
  seq_cols <- tbl |> select(contains('pos'))
  n_col <- seq_cols  |> ncol()
  
  breaks <- scales::breaks_width(width, 0)(c(1, n_col))
  
  # handle case where breaks extend beyond data
  breaks <- intersect(breaks, 1:n_col)
  
  col_breaks <- colnames(seq_cols[,breaks])
  return(col_breaks)
}

breaks <- generate_breaks(tbl_data)
```

#  

::: {.panel-tabset .nav-pills}

## Spike Protein

```{r}
#| column: screen
base_table <- tbl_data |> 
  gt(rowname_col = c('name'), groupname_col = 'group') |> 
  
  # add consensus sequence
  grand_summary_rows(
    columns = contains('pos'),
    fns = list(
      Consensus ~ get_consensus_return_bar(.) |> 
        div(style = 'width:100%;height:50px;') |> 
        as.character(),
      Sequence ~ names(get_consensus(.)) |> 
        
        # change to double dash, otherwise fmt_markdown turns it into a list (ul)
        stringr::str_replace('-', '--')
    ),
    fmt =   list(
      bar ~  fmt_markdown(.)
    ),
    missing = ''
  ) |> 
  
  ## style consensus sequence
  ### make sure that the consensus sequence elements are centered
  tab_style(
    style = cell_text(align = 'center'),
    locations = cells_grand_summary(columns = contains('pos_'))
  ) |> 
  tab_style(
    style = cell_borders(sides = 'bottom', style = 'hidden'),
    locations = list(cells_grand_summary(rows = 1), cells_stub_grand_summary(rows = 1))
  ) |> 
  
  # style the sequence elements: center elements, adjust size
  tab_style(
    style = cell_text(
      size = "small",
      align = 'center',
      indent = 0
    ),
    locations = list(cells_body(columns = contains('pos_')), cells_grand_summary(columns = contains('pos_')))
  ) |>
  cols_width(
    1 ~ px(60),
    name ~ px(50),
    start ~ px(40), 
    everything() ~ px(13)
  ) |> 
  cols_align( 'right', group:start) |> 
  
  # breaks
  cols_label_with(
    fn = ~ifelse(. %in% breaks, ., '') |>  str_remove('pos_'), 
    columns = contains('pos_')
  ) |>  
  
  # remove borders from the table body
  tab_style(
    style = list(
      cell_borders(
        sides = 'all',
        weight = px(0)
      )
    ),
    locations = list(
      cells_body()
    )
  ) |> 
  
  # annotation regions in the alignment
  tab_spanner(
    columns = pos_1:pos_21,
    label = 'Stem helix'
  ) |> 
  tab_spanner(
    columns = pos_33:pos_80,
    label = "HR2 region"
  ) |> 
  tab_spanner(
    columns = pos_91:pos_95,
    label = "TM region"
  ) |> 
  
  # add a rectangle to highlight region
  tab_style(
    style = cell_borders(sides = 'left', weight = px(2)),
    locations = cells_body(columns = pos_11)
  ) |> 
  tab_style(
    style = cell_borders(sides = 'right', weight = px(2)),
    locations = cells_body(columns = pos_18)
  ) |> 
  tab_style(
    style = cell_borders(sides = c('top'),  weight = px(2)),
    locations = cells_body(columns = pos_11:pos_18, rows = 1)
  )|> 
  
  # For the bottom border of the rectangle, need to target the top border of grand summary, if present
  # if grand summary is not present, need to target the bottom of the cells_body
  tab_style(
    style = cell_borders(sides = c('top'),  weight = px(2), style = 'solid'),
    locations = cells_grand_summary(columns = pos_11:pos_18, rows = 1)
  )  |> 
  
  # epitope
  cols_label(
    pos_14 ~ '*',
    pos_15 ~ '',
    pos_16 ~ '*',
    pos_17 ~ '*',
    pos_19 ~ '!',
  ) |> 
  
  # borders, style
  tab_options(
    
    row_group.as_column = TRUE,
    table.font.size = 14,
    
    # adjust padding in the cell body
    data_row.padding.horizontal = px(2), 
    data_row.padding = px(2),
    
    # adjust padding in the grand summary
    # Noting that padding creates space between the bars (which have 100% width)
    grand_summary_row.padding.horizontal = px(0), 
    grand_summary_row.padding = px(2),
    
    # # remove borders
    table.border.top.style = "hidden",
    grand_summary_row.border.width = px(2)
  )  
base_table |> 
  gt::data_color(columns = contains('pos_'), fn = apply_color_to_aa(palette = 'Chemistry_AA')) 
```

This is my re-creation of the msa figure of coronavirus spike proteins. I implemented a palette that groups chemically similar amino acids together:

- Acidic amino acids glutamic (E) and aspartic acid (D) are [red]{style="background-color: #ff6d6d;"}
- Nonpolar/hydrophobic amino acids proline (P), alanine (A), valine (V), methionine (M), leucine (L), isoleucine (I), and glycine (G) are [orange]{style="background-color: #f2be3c;"}
- Basic amino acids lysine (K) and arginine (R) are [blue]{style="background-color: #769dcc;"}
- Polar amino acids asparagine (N), threonine (T), cysteine (C), glutamine (Q), and serine (S) are [green]{style="background-color: #74ce98;"}
- Aromatic amino acids phenylalanine (F), tyrosine (Y), and tryptophan (W) are [yellow]{style="background-color: #ffff66;"}

## Core Epitope Region


```{r}
#| column: screen
base_table |> 
  gt::data_color(columns = pos_11:pos_19, fn = apply_color_to_aa(palette = 'Chemistry_AA')) 
```

The authors fixate on this particular highlighted region, which is where the binding to their antibodies happen (which arenamed 28D9 and 1.6C7, very creative right?). This region is referred to as the "core epitope", and asterisks are indicating the key amino acids that are critical for binding. The authors identified these key amino acids through an experiment of changing each amino acid one at a time, systematically measuring if any amino acid change would impact binding. Importantly, some variability within this epitope region can occur without affecting binding, which is clearly shown by this figure. 

The exclamation point marks an adjacent amino acid which the authors refer to as a "conserved glycosylation sequon", or "NxS/T". This means this is an amino acid that sugar can attach to, and it follows the pattern of "the amino acid N, followed by any amino acid X, and then either an S or a T". Apparently this is a conserved pattern among coronavirus species. What's significant here is the authors suggest that this sugar molecule may be potentially important for the binding of these antibodies to this epitope.

## Stem helix

```{r}
#| column: screen
base_table |> 
  gt::data_color(columns = pos_1:pos_21, fn = apply_color_to_aa(palette = 'Shapely_AA')) 
```

The stem helix region refers to a part of the protein that forms a spiral like structure. It's the orange part highlighted here:

![](stem_helix.png){height=4in}

## HR2 region

The epitope occurs upstream of the Heptad Repeat Region 2 (HR2). Why is it called "Heptad Repeat", because this is region where every 7 amino acids tends to be repeated. 

Can you spot the pattern? (If you can, do let me know because I can't)

```{r}
#| column: screen
base_table |> 
  gt::data_color(columns = pos_33:pos_80, fn = apply_color_to_aa(palette = 'LETTER')) 
```

## Hydrophicity

Heptad repeat regions are typically identified via 3d structural modelling. Meaning, it is unlikely to be observed on a raw linear amino acid sequence. The exact amino acid length of each repeat is also imperfect, and not necessarily is the same amino acid repeated, but just one that is highly similar - usually a hydrophobic amino acid (e.g. leucine, valine, phenylalanine).

Still we can visualize this region by each amino acids relative hydrophobicity, and then we can see there is generally-speaking a repetitive nature to this region.

Hydrophobicity

```{r}
#| column: screen
base_table |> 
  gt::data_color(columns = pos_33:pos_80, fn = apply_color_to_aa(palette = 'Hydrophobicity')) 
```

## TM region

:::